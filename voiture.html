<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Jeu de Voiture Arcade 3D</title>
  <style>
    body {
      margin: 0;
      background: linear-gradient(to bottom, #87ceeb, #e0f7fa); /* ciel clair dÃ©gradÃ© */
      overflow: hidden;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: #fff;
    }
    #hud {
      position: absolute;
      top: 15px;
      left: 0;
      width: 100%;
      display: flex;
      justify-content: space-between;
      padding: 0 30px;
      font-size: 18px;
      pointer-events: none;
    }
    #hud div {
      background: linear-gradient(135deg, rgba(0,0,0,0.5), rgba(60,60,60,0.4));
      border-radius: 20px;
      padding: 12px 24px;
      min-width: 140px;
      text-align: center;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      font-weight: bold;
      letter-spacing: 1px;
    }
    #gameOverMenu {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%,-50%);
      background: rgba(255,255,255,0.9);
      padding: 40px 60px;
      border-radius: 25px;
      font-size: 28px;
      text-align: center;
      color: #333;
      box-shadow: 0 8px 20px rgba(0,0,0,0.4);
      animation: popin 0.5s ease;
    }
    #gameOverMenu h1 {
      margin: 0 0 15px;
      font-size: 36px;
      color: #e63946;
    }
    #gameOverMenu p {
      margin: 10px 0;
      font-size: 20px;
    }
    #gameOverMenu span {
      display: block;
      margin-top: 20px;
      font-size: 18px;
      color: #555;
    }
    @keyframes popin {
      from { transform: translate(-50%,-50%) scale(0.7); opacity: 0; }
      to { transform: translate(-50%,-50%) scale(1); opacity: 1; }
    }
    canvas { display:block; }
  </style>
</head>
<body>
<div id="hud">
  <div id="score">Score: 0</div>
  <div id="speed">Vitesse: 0 km/h</div>
  <div id="best">Record: 0</div>
</div>
<div id="gameOverMenu"></div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x87ceeb, 30, 150);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 500);
camera.position.set(0,5,10);
camera.lookAt(0,0,0);

scene.add(new THREE.HemisphereLight(0xffffff,0x87ceeb,0.9));
const light = new THREE.DirectionalLight(0xffffff,0.9);
light.position.set(5,10,5);
scene.add(light);

const roadGeo = new THREE.PlaneGeometry(6,200);
const roadMat = new THREE.MeshPhongMaterial({color:0x2d2d2d});
const road = new THREE.Mesh(roadGeo, roadMat);
road.rotation.x = -Math.PI/2;
road.position.z = -80;
scene.add(road);

const laneX = (i)=> (i-1)*2;

// Car
const car = new THREE.Group();
const body = new THREE.Mesh(new THREE.BoxGeometry(1,0.5,2), new THREE.MeshPhongMaterial({color:0x999999}));
body.position.y=0.25;
car.add(body);
const roof = new THREE.Mesh(new THREE.BoxGeometry(0.8,0.3,1.2), new THREE.MeshPhongMaterial({color:0xcccccc}));
roof.position.y=0.65;
car.add(roof);

const wheelGeo = new THREE.CylinderGeometry(0.25,0.25,0.2,16);
const wheelMat = new THREE.MeshPhongMaterial({color:0x333333});
const wheelOffsets = [[-0.6,0,-0.9],[0.6,0,-0.9],[-0.6,0,0.9],[0.6,0,0.9]];
for(const [x,y,z] of wheelOffsets){
  const w = new THREE.Mesh(wheelGeo,wheelMat);
  w.rotation.z=Math.PI/2;
  w.position.set(x,0.25,z);
  car.add(w);
}
car.position.set(0,0,5);
scene.add(car);

// Obstacles
let obstacles = [];
function spawnObstacle(){
  let lanes=[0,1,2];
  const count = Math.random()<0.5?1:2; // 1 ou 2 obstacles
  for(let i=0;i<count;i++){
    const idx = Math.floor(Math.random()*lanes.length);
    const lane=lanes.splice(idx,1)[0];
    const g = new THREE.BoxGeometry(1,0.7,2);
    const m = new THREE.MeshPhongMaterial({color:[0xe63946,0xf77f00,0xffb703][Math.floor(Math.random()*3)]});
    const o = new THREE.Mesh(g,m);
    o.position.set(laneX(lane),0.35,-80);
    scene.add(o);
    obstacles.push(o);
  }
}

// Trees
let trees = [];
function spawnTree(){
  const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.1,0.1,0.5,8), new THREE.MeshPhongMaterial({color:0x795548}));
  const foliage = new THREE.Mesh(new THREE.SphereGeometry(0.5,8,8), new THREE.MeshPhongMaterial({color:0x34a853}));
  foliage.position.y=0.5;
  const tree = new THREE.Group();
  tree.add(trunk);
  tree.add(foliage);
  tree.position.set(Math.random()<0.5?-4:4,0.25,-80);
  scene.add(tree);
  trees.push(tree);
}

// Controls
let targetLane = 1;
window.addEventListener('keydown', e=>{
  if(gameOver){
    if(e.key===' '){ document.location.reload(); }
    return;
  }
  if(e.key==='ArrowLeft' && targetLane>0) targetLane--;
  if(e.key==='ArrowRight' && targetLane<2) targetLane++;
});

// HUD
let score=0;
let best = Number(localStorage.getItem('bestScore')||0);
let speed = 10;
const scoreEl=document.getElementById("score");
const bestEl=document.getElementById("best");
const speedEl=document.getElementById("speed");
const gameOverMenu=document.getElementById("gameOverMenu");

// Game state
let gameOver=false;

function endGame(){
  gameOver=true;
  best=Math.max(best,Math.floor(score));
  localStorage.setItem('bestScore',String(best));
  gameOverMenu.innerHTML = `
    <h1>ðŸš— CRASH !</h1>
    <p>Score: ${Math.floor(score)}</p>
    <p>Record: ${best}</p>
    <span>Appuie ESPACE pour recommencer</span>
  `;
  gameOverMenu.style.display="block";
}

// Collision helper
const carBox=new THREE.Box3();
const tmpBox=new THREE.Box3();

let last=0;
function animate(t){
  const dt=(t-last)/1000||0; last=t;
  if(gameOver){
    renderer.render(scene,camera);
    requestAnimationFrame(animate);
    return;
  }

  speed += dt*2;
  score += dt*speed;

  const targetX=laneX(targetLane);
  car.position.x += (targetX-car.position.x)*dt*10;

  road.position.z += speed*dt;
  if(road.position.z>0) road.position.z=-80;

  for(const o of obstacles){ o.position.z += speed*dt; }
  for(const t of trees){ t.position.z += speed*dt; }

  obstacles = obstacles.filter(o=>{ if(o.position.z>10){ scene.remove(o); return false;} return true; });
  trees = trees.filter(tr=>{ if(tr.position.z>10){ scene.remove(tr); return false;} return true; });

  // Collisions
  carBox.setFromObject(car).expandByScalar(-0.2);
  for(const o of obstacles){
    tmpBox.setFromObject(o).expandByScalar(-0.2);
    if(carBox.intersectsBox(tmpBox)){
      endGame();
      return;
    }
  }

  scoreEl.textContent = "Score: "+Math.floor(score);
  bestEl.textContent = "Record: "+best;
  speedEl.textContent = "Vitesse: "+Math.floor(speed)+" km/h";

  renderer.render(scene,camera);
  requestAnimationFrame(animate);
}

setInterval(spawnObstacle,1200);
setInterval(spawnTree,1000);

animate();
</script>
</body>
</html>
